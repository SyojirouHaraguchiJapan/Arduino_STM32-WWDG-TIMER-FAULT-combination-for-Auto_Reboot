#define USE_FORCE_WWDG_REBOOT    // newly add for Auto Reboot
#define USE_BACKUP_RAM

#define USE_COUNTED_BLINK
#define DELAY_COUNT 12000
/*
 * Re-define ERROR_LED and ERROR_LED_PIN to PC13_LED for fit to BluePill
 */
#if defined(ERROR_LED_PORT) && defined(ERROR_LED_PIN)
#undef  ERROR_LED_PORT
#undef  ERROR_LED_PIN
#endif

#define ERROR_LED_PORT   GPIOC
#define ERROR_LED_PIN    13

/******************************************************************************
 * The MIT License
 *
 * Copyright (c) 2010 Perry Hung.
 * Copyright (c) 2011, 2012 LeafLabs, LLC.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *****************************************************************************/

/**
 * @file libmaple/util.c
 * @brief Utility procedures for debugging
 */

#include <libmaple/libmaple.h>
#include <libmaple/usart.h>
#include <libmaple/gpio.h>
#include <libmaple/nvic.h>

#ifdef USE_BACKUP_RAM       // #251002 add
#include <libmaple/scb.h>
#include <libmaple/bkp.h>
//#include <libmaple/rtc.h> // #251004 There is no "rtc.h" for STM32F1, but STM32F4.
#endif

/* (Undocumented) hooks used by Wirish to direct our behavior here */
extern __weak void __lm_error(void);
extern __weak usart_dev* __lm_enable_error_usart(void);

/* If you define ERROR_LED_PORT and ERROR_LED_PIN, then a failed
 * ASSERT() will also throb() an LED connected to that port and pin.
 */
#if defined(ERROR_LED_PORT) && defined(ERROR_LED_PIN)
#define HAVE_ERROR_LED
#endif

/* (Called from exc.S with global interrupts disabled.) */
__attribute__((noreturn)) void __error(void) {
    if (__lm_error) {
        __lm_error();
    }
    /* Reenable global interrupts */
    nvic_globalirq_enable();
	throb();
}

/*
 * Print an error message on a UART upon a failed assertion (if one is
 * available), and punt to __error().
 *
 * @param file Source file of failed assertion
 * @param line Source line of failed assertion
 * @param exp String representation of failed assertion
 * @sideeffect Turns of all peripheral interrupts except USB.
 */
void _fail(const char* file, int line, const char* exp) {
    if (__lm_enable_error_usart) {
        /* Initialize the error USART */
        usart_dev *err_usart = __lm_enable_error_usart();

        /* Print failed assert message */
        usart_putstr(err_usart, "ERROR: FAILED ASSERT(");
        usart_putstr(err_usart, exp);
        usart_putstr(err_usart, "): ");
        usart_putstr(err_usart, file);
        usart_putstr(err_usart, ": ");
        usart_putudec(err_usart, line);
        usart_putc(err_usart, '\n');
        usart_putc(err_usart, '\r');
    }
    /* Shutdown and error fade */
    __error();
}

/*
 * Provide an __assert_func handler to libc so that calls to assert()
 * get redirected to _fail.
 */
void __assert_func(const char* file, int line, const char* method __attribute__((unused)),
                   const char* expression) {
    _fail(file, line, expression);
}

/*
 * Provide an abort() implementation that aborts execution and punts
 * to __error().
 */
void abort() {
    if (__lm_enable_error_usart) {
        /* Initialize the error USART */
        usart_dev *err_usart = __lm_enable_error_usart();
        /* Print abort message. */
        usart_putstr(err_usart, "ERROR: PROGRAM ABORTED VIA abort()\r\n");
    }

    /* Shutdown and error fade */
    __error();
}

/* This was public as of v0.0.12, so we've got to keep it public. */
/**
 * @brief Fades the error LED on and off
 * @sideeffect Sets output push-pull on ERROR_LED_PIN.
 */
__attribute__((noreturn)) void throb(void) {

#ifdef HAVE_ERROR_LED
    int32  slope   = 1;
    uint32 CC      = 0x0000;
    uint32 TOP_CNT = 0x0200;
    uint32 i       = 0;

  #ifdef USE_COUNTED_BLINK
    uint32 j;
    uint32 cause;
    asm volatile (
        "mov %0, r0"   // assembly instruction: move r0 value to opernd 0 (%0)
        : "=r" (cause) // output operand: C variable cause
        :              // input  operand: none
        : "r0"         // may destroy register
    );
  #endif

  #ifdef USE_BACKUP_RAM    // #251002 add
typedef struct rtc_reg_map {
    __IO uint32 CRH;        /**< Control register high */
    __IO uint32 CRL;        /**< Control register high */
    __IO uint32 PRLH;       /**< Prescaler load register high */
    __IO uint32 PRLL;       /**< Prescaler load register low */
    __IO uint32 DIVH;       /**< Prescaler divider register high */
    __IO uint32 DIVL;       /**< Prescaler divider register low */
    __IO uint32 CNTH;       /**< Counter register high */
    __IO uint32 CNTL;       /**< Counter register low */
    __IO uint32 ALRH;       /**< Alarm register high */
    __IO uint32 ALRL;       /**< Alarm register low */
} rtc_reg_map;

#define RTC_BASE            ((struct rtc_reg_map*)0x40002800)
#define RTC_FLAG_RTOFF      (uint32_t) 0x00000020
#define RTC_FLAG_CNF        (uint32_t) 0x00000010
#define RTC_FLAG_RSF        (uint32_t) 0x00000008

    /* get unix time from RTC register by direct access */
    // rtc_clear_sync()
    while (RTC_BASE->CRL & RTC_FLAG_RTOFF == 0);    // wait until previous write complete
    RTC_BASE->CRL &= ~RTC_FLAG_RSF;                 // clear reg sync flag
    // rtc_wait_sync()
    while((RTC_BASE->CRL & RTC_FLAG_RSF) == 0);     // wait until sync
    // rtc_wait_finished()
    while (RTC_BASE->CRL & RTC_FLAG_RTOFF == 0);    // wait until previous write complete
    uint32 h, l;
    do {
        h = RTC_BASE->CNTH & 0xffff;
        l = RTC_BASE->CNTL & 0xffff;
    } while (h != (RTC_BASE->CNTH & 0xffff));

uint16_t bkp_end = BKP_NR_DATA_REGS;

    bkp_enable_writes();

    bkp_write(bkp_end-10, (uint16_t) cause);    // Fault cause number

uint32_t reg_data;
    reg_data = SCB_BASE->CFSR;
    bkp_write(bkp_end-9, (uint16_t) (reg_data >> 16));
    bkp_write(bkp_end-8, (uint16_t) (reg_data & 0xFFFF));

    //reg_data = SCB_BASE->HFSR;
    //bkp_write(bkp_end-8, (uint16_t) (reg_data >> 16));
    //bkp_write(bkp_end-7, (uint16_t) (reg_data & 0xFFFF));
    reg_data = ((SCB_BASE->HFSR >> 16) & 0xC000) | (SCB_BASE->HFSR & 0x0002);
    bkp_write(bkp_end-7, (uint16_t) reg_data);

    reg_data = SCB_BASE->MMFAR;
    bkp_write(bkp_end-6, (uint16_t) (reg_data >> 16));
    bkp_write(bkp_end-5, (uint16_t) (reg_data & 0xFFFF));

    reg_data = SCB_BASE->BFAR;
    bkp_write(bkp_end-4, (uint16_t) (reg_data >> 16));
    bkp_write(bkp_end-3, (uint16_t) (reg_data & 0xFFFF));

    bkp_write(bkp_end-2, (uint16_t) h);
    bkp_write(bkp_end-1, (uint16_t) l);

    bkp_disable_writes();
  #endif

  #ifdef USE_FORCE_WWDG_REBOOT    // newly add
    /* Disable global interrupts */
    nvic_globalirq_disable();
  #endif

    gpio_set_mode(ERROR_LED_PORT, ERROR_LED_PIN, GPIO_MODE_OUTPUT);

  #ifdef USE_COUNTED_BLINK
    /* Error blink */
    cause &= 0x07;     // limit max 7
    if (cause > 5 || cause < 1) {
        cause = 6;
    }
    while(1) {
        for(j=0; j<cause; j++) {
            gpio_write_bit(ERROR_LED_PORT, ERROR_LED_PIN, 0);   // LED ON
            i=DELAY_COUNT; while (i>0) {int k = sqrt(i); i--; }
            gpio_write_bit(ERROR_LED_PORT, ERROR_LED_PIN, 1);   // LED OFF
            i=DELAY_COUNT; while (i>0) {int k = sqrt(i); i--; }
        }
        for (j=cause; j<7; j++) {
            gpio_write_bit(ERROR_LED_PORT, ERROR_LED_PIN, 1);   // LED OFF
            i=DELAY_COUNT; while (i>0) {int k = sqrt(i); i--; }
            i=DELAY_COUNT; while (i>0) {int k = sqrt(i); i--; }
        }
    }
  #else 
    /* Error fade. */
    while (1) {
        if (CC == TOP_CNT)  {
            slope = -1;
        } else if (CC == 0) {
            slope = 1;
        }

        if (i == TOP_CNT)  {
            CC += slope;
            i = 0;
        }

        if (i < CC) {
            gpio_write_bit(ERROR_LED_PORT, ERROR_LED_PIN, 1);
        } else {
            gpio_write_bit(ERROR_LED_PORT, ERROR_LED_PIN, 0);
        }
        i++;
    }
  #endif
#else
    /* No error LED is defined; do nothing. */
    while (1)
        ;
#endif
}
